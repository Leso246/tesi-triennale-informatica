\section{Creazione dei meeting}
\subsection{Frontend}
Attualmente, non è implementato alcun metodo per la creazione dei meeting attraverso il frontend del sistema. 
L'idea di base è che gli utenti possano cercare annunci di lavoro creati dalle aziende utilizzando una barra di ricerca dedicata.
Gli utenti potrebbero inserire parole chiave, filtri di posizione o settore, e altre specifiche per trovare gli annunci 
che corrispondono ai loro interessi e competenze. Allo stesso modo, le aziende potrebbero cercare utenti basandosi 
sulle informazioni presenti nei loro profili, come competenze, esperienze lavorative, certificazioni, e altre informazioni pertinenti. 
\\
\\
Dopo aver individuato un annuncio di interesse o un utente potenziale, è possibile richiedere un incontro 
mediante un apposito pulsante, attraverso il quale si forniscono le proprie disponibilità per il meeting. 
L'utente o l'azienda potrebbe specificare una serie di fasce orarie e date preferite, offrendo così flessibilità alla controparte. 
Nel caso in cui la controparte accetti l'invito scegliendo una data tra quelle disponibili, il sistema 
dovrebbe procedere automaticamente con la creazione del meeting, aggiornando i calendari delle parti coinvolte.
\\
\\
Tuttavia, sussiste un problema fondamentale: al momento, manca l'implementazione della logica di ricerca degli annunci 
e degli utenti, la creazione degli annunci da parte delle aziende e il completamento dei profili da parte degli utenti, 
rendendo impossibile anche la relativa visualizzazione. Di conseguenza, la funzionalità per la creazione automatica 
dei meeting non è stata implementata.
\subsection{Backend}
La creazione di un meeting nel backend viene gestita tramite una chiamata POST all'API \texttt{\//addMeet} con il seguente body:
\begin{lstlisting}[language=json,firstnumber=1]
{
    "data_inizio": "2024-06-25T16:00:00.000Z", 
    "data_fine": "2024-06-25T17:00:00.000Z",   
    "azienda": "techSPA@gmail.com", 
    "utente": "mario@gmail.com",
    "invitati": [azienda1@outlook.com, azienda2@virgilio.it]
}
\end{lstlisting}
\begin{itemize}
    \item \textbf{Azienda}: l'email con cui l'azienda si è registrata su RisUma.
    \item \textbf{Utente}: l'email con cui l'utente si è registrata su RisUma.
    \item \textbf{Invitati}: un array contenente le email du ulteriori invitati, nel caso più persone dell'azienda volessero 
    partecipare al colloquio. Questo attributo è opzionale; può essere vuoto o assente, e la creazione del meeting andrà comunque a buon fine.
\end{itemize}
\vspace{0.2cm}
{\large \textbf{Controller}}
\begin{lstlisting}[language=java, frame=lines, basicstyle=\ttfamily\scriptsize, numbers=left]
@PostMapping(value = "/addMeet", consumes = "application/json")
public ResponseEntity<?> addMeeting(@RequestBody ObjectNode obj) {
  try {
	Mono<Boolean> resultMono = serviceMeet.addMeet(obj);
	Boolean result = resultMono.toFuture().get();

	if (result) {
	  return new ResponseEntity<>(result, HttpStatus.OK);
	} else {
	  return new ResponseEntity<>(result, HttpStatus.INTERNAL_SERVER_ERROR);
	}
  } catch (Exception e) {
	e.printStackTrace();
	return new ResponseEntity<>(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
  }
}    
\end{lstlisting}
\begin{itemize}
    \item \textbf{Riga 1}:
    l'annotazione indica che il metodo risponde a richieste HTTP POST sull'URL /addMeet 
    e che il body della richiesta deve essere in formato JSON.
  
    \item \textbf{Riga 2}:
    questo è il metodo che gestisce la richiesta HTTP. 
        \begin{itemize}
            \item \textbf{ResponseEntity\textless{}?{}\textgreater{}}: \texttt{ResponseEntity} è una classe di Spring che 
            rappresenta l'intera risposta HTTP inviata al client. Il tipo generico "\textless{}?\textgreater{}" indica che il corpo 
            della risposta può essere di qualsiasi tipo. In altre parole, il metodo può restituire una risposta che può 
            contenere dati di qualsiasi tipo.
            
            \item \textbf{@RequestBody ObjectNode obj}: è un'annotazione di Spring che indica al framework di 
            utlizzare il corpo della richiesta HTTP per popolare \texttt{obj}, \texttt{ObjectNode} è un oggetto fornito 
            dalla libreria \textbf{Jackson} utile a rappresentare JSON in Java.
            
        \end{itemize}
  
    \item \textbf{Riga 4}:
    all'interno del blocco try, viene chiamato il \textbf{service} attraverso
    \texttt{serviceMeet.addMeet(obj)}, che restituisce un oggetto 
    \texttt{Mono\textless{}Boolean\textgreater{}}. 
    %La classe \texttt{Mono} è parte del progetto Reactor, utilizzato per la programmazione reattiva in Java.
  
    \item \textbf{Riga 5}:
    il risultato del Mono viene convertito in un Future e poi ottenuto. Questo metodo blocca l'esecuzione 
    finché il risultato non è disponibile.
  
    \item \textbf{Riga 7}:
    se il risultato è \texttt{true}, viene restituita una risposta HTTP con lo stato OK (200), altrimenti
    viene restituita una risposta con lo stato INTERNAL_SERVER_ERROR (500).
  
    \item \textbf{Riga 12}:
    se si verifica un'eccezione durante l'esecuzione, l'eccezione viene stampata nello stack trace e viene 
    restituita una risposta con lo stato INTERNAL_SERVER_ERROR (500), contenente il messaggio dell'eccezione.
  \end{itemize}
\vspace{0.3cm}
\noindent {\large \textbf{Service}}
\begin{lstlisting}[language=java, frame=lines, basicstyle=\ttfamily\scriptsize, numbers=left]
public Mono<Boolean> addMeet(ObjectNode obj) {
  try {
    Azienda azienda = aziendaService.trovaPerEmail(obj.get("azienda").asText());
    Utente utente = utenteService.trovaPerEmail(obj.get("utente").asText());

    String usernameAzienda = azienda.getAnagraficaAz().getNome();
    String usernameUtente = utente.getUsername();

    return CreateMeeting
      .addWebexMeet(webexAPI, obj, usernameAzienda, usernameUtente)
      .flatMap(response -> {

	    JsonNode jsonResponse = (JsonNode) response;
	    String webLink = jsonResponse.get("webLink").asText();
	    String meetingID = jsonResponse.get("id").asText();

	    CreateMeeting.addMeetToDatabase(obj, azienda, utente, repo, webLink, meetingID);

	    return Mono.just(true);
    }).doOnError(error -> {
         System.err.println("Errore durante la creazione del meeting su Webex: "
         + error.getMessage());
    }).onErrorReturn(false);
  } catch (Exception e) {
     e.printStackTrace();
     return Mono.just(false);
    }
}
\end{lstlisting}
\begin{itemize}
    \item \textbf{Righe 3-7}: vengono recuperati dal database il nome dell'azienda e lo username dell'utente invitati al meeting. 
    Questo passaggio è fondamentale perché, come precedentemente menzionato, si intende limitare la comunicazione tra candidati 
    e aziende esclusivamente attraverso RisUma. Poiché Webex invia una mail di notifica alla creazione del meeting, e non si voleva
    disabilitare questa funzione, nella mail verranno mostrati i rispettivi username al posto degli indirizzi email degli invitati.

    \item \textbf{Riga 10}: viene invocato il metodo responsabile della creazione del meeting sul database di Webex.

    \item \textbf{Righe 11-19}: se la creazione del meeting su Webex ha avuto successo, il flusso d'esecuzzione passa al 
    blocco \texttt{flatmap}. In questo blocco, vengono recuperati l'\texttt{ID} e il \texttt{link} della riunione dal JSON di risposta 
    e viene chiamato il metodo per aggiungere il meeting anche nel database aziendale.
    \\\\
    \textit{Nota: è fondamentale che, se la creazione del meet su Webex non ha avuto successo, il metodo
    \texttt{addMeetToDatabase} non venga eseguito. Altrimenti, si rischierebbe di mostrare a frontend riunioni inesistenti.
    Per tale motivo nel caso in cui venga generato un errore da Webex il flusso d'esecuzione non viene passatto al blocco \texttt{flatmap}}.
\end{itemize}
\noindent {\large \textbf{CreateMeeting}}
\\
\\
Metodo per creare il meet su Webex:
\begin{lstlisting}[language=java, frame=lines, basicstyle=\ttfamily\scriptsize, numbers=left]
public static Mono<JsonNode> addWebexMeet(
    WebClient webexAPI, 
    ObjectNode obj, 
    String usernameAzienda,
    String usernameUtente) {

  String requestBody = createAddWebexMeetBody(obj, usernameAzienda, usernameUtente);

  return webexAPI.post()
    .uri(MeetingAPI.ADD_WEBEX_MEET)
    .header(HttpHeaders.AUTHORIZATION, "Bearer " + MeetingAPI.TOKEN)
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(requestBody)
    .retrieve()
    .bodyToMono(String.class).map(responseBody -> {

        ObjectMapper objectMapper = new ObjectMapper();
            
        try {
            JsonNode jsonResponse = objectMapper.readTree(responseBody);
            return jsonResponse;
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Errore durante il parsing della risposta JSON", e);
        }
    }).onErrorMap(e -> 
                    new RuntimeException("Errore durante la chiamata all'API di Webex", e));
}
\end{lstlisting}
\begin{itemize}
    \item \textbf{Riga 7}: \texttt{createAddWebexMeetBody} è un metodo di utilità che permette di creare il body
    della richiesta per l'API di Webex. Esempio:
    \begin{lstlisting}[language=json,firstnumber=1]
{
    "title": "Riunione tra Mario e Tech SPA",
    "start": "2024-06-25T16:00:00",
    "end": "2024-06-25T17:00:00",
    "invitees": [
        {
            "email": "techSPA@gmail.com",
            "displayName": "Tech SPA",
            "coHost": false
        },
        {
            "email": "mario@gmail.com",
            "displayName": "Mario",
            "coHost": false
        }
    ],
    "timezone": "Europe/Rome",
    "enabledJoinBeforeHost": true,
    "enableConnectAudioBeforeHost": true,
    "joinBeforeHostMinutes": 15,
    "scheduledType": "meeting",
    "enableAutomaticLock": true,
    "automaticLockMinutes": 60
}
    \end{lstlisting}
    \begin{itemize}
        \item \textbf{title}: titolo della riunione.
        \item \textbf{start}: data e ora d'inizio della riunione, formattata secondo lo standard ISO 8601.
        \item \textbf{end}: data e ora di fine della riunionw, formattata secondo lo standard ISO 8601.
        \item \textbf{invitees}: lista degli invitati alla riunione. Webex invierà una mail agli indirizzi specificati, il nome
        visualizzato è il valore contenuto in \texttt{displayName}.
        \item \textbf{timezone}: il fuso orario in cui si terrà il meet.
        \item \textbf{enabledJoinBeforeHost}: permette ai partecipanti di unirsi alla riunione anche senza la presenza dell'host. 
        Questo attributo è fondamentale poiché l'azienda è l'organizzatrice di tutti i meeting ma non parteciperà a nessuno di essi.
        \item \textbf{enableConnectAudioBeforeHost}: permette ai partecipanti di utilizzare l'audio anche in assenza dell'host.
        \item \textbf{joinBeforeHostMinutes}: indica quanti minuti rispetto alla data di inizio della riunione i partecipanti possono unirsi anche senza la presenza dell'host.
        \item \textbf{scheduledType}: indica il tipo di riunione, in questo caso è un meeting.
        \item \textbf{enableAutomaticLock}: dopo un certo periodo di tempo, nessuno può partecipare al meeting senza essere accettato dall'host.
        \item \textbf{automaticLockMinutes}: indica il periodo di tempo dopo il quale la riunione verrà automaticamente bloccata, 
        calcolato come \texttt{end} - \texttt{start} in modo che, dopo la data di fine prefissata, nessuno possa più partecipare.
    \end{itemize}

    \item \textbf{Righe 9-15}: viene effettuata una chiamata POST all'API 
    \\ \texttt{https://webexapis.com/v1/meetings}, utilizzando il token d'autorizzazione \hyperref[sec:recupero_access_token]{generato} 
    e passando come body il JSON precedentemente creato.

    \item \textbf{Righe 20-21}: se la richiesta è andata a buon fine, viene restituito come risposta il JSON fornito dall'API di Webex.
    
\end{itemize}
Metodo per creare il meet a database:
\begin{lstlisting}[language=java, frame=lines, basicstyle=\ttfamily\scriptsize, numbers=left]
public static void addMeetToDatabase(
    ObjectNode obj, 
    Azienda azienda, 
    Utente utente, 
    MeetJPA repo, 
    String link,
    String webexId) {

  try {
    
    Meet meet = new Meet();
  
    Timestamp dataInizio = Timestamp.valueOf(UtiltyMeet.transformUTCIntoRomeTimezone(obj.get("data_inizio").asText()));
    Timestamp dataFine = Timestamp.valueOf(UtiltyMeet.transformUTCIntoRomeTimezone(obj.get("data_fine").asText()));

    meet.setDataInizio(dataInizio);
    meet.setDataFine(dataFine);
    meet.setAzienda(azienda);
    meet.setUtente(utente);
    meet.setLink(link);
    meet.setWebexId(webexId);

    repo.save(meet);

  } catch (Exception e) {
    throw new RuntimeException("Errore durante la creazione del meeting al database", e);
  }
}
\end{lstlisting}
Questo metodo utilizza JPA per creare facilmente un record nella tabella \textbf{meet} del database.
\\
\\
\textit{Nota: il frontend fornisce le date nel fuso orario UTC+0. Pertanto, è stato creato 
un metodo \texttt{transformUTCIntoRomeTimezone} per convertire le date nel fuso orario di Roma. 
Questo garantisce che le date siano corrette rispetto alla localizzazione del sistema.}